options{  JDK_VERSION = "1.7";  static = false;}PARSER_BEGIN(LQMLParser)package io.github.luzzu.qml.parser;import java.io.Reader ;import java.io.StringReader ;import java.util.ArrayList;import java.util.List;import java.util.Map ;import java.util.HashMap ;import io.github.luzzu.qml.datatypes.conditions.CustomCondition;import io.github.luzzu.qml.datatypes.conditions.DefinedCondition;import io.github.luzzu.qml.datatypes.conditions.Condition;import io.github.luzzu.qml.datatypes.conditions.ConditionType;import io.github.luzzu.qml.datatypes.Metric;import io.github.luzzu.qml.datatypes.actions.ActionType;import io.github.luzzu.qml.datatypes.actions.Action;import io.github.luzzu.qml.datatypes.functions.Function;import io.github.luzzu.qml.datatypes.functions.FunctionType;import io.github.luzzu.qml.datatypes.functions.FunctionParam;import io.github.luzzu.qml.datatypes.functions.FunctionParamType;import io.github.luzzu.qml.datatypes.Rule;import io.github.luzzu.qml.datatypes.RuleSet;public class LQMLParser{  static Map<String,String> compilerMap;   static String def, label, desc, metricUri, agentUri, estimate;  //static Rule rule;  static Action action;  static RuleSet rules;  static Function finalVal;  Map<String,CustomCondition> customConditions;  public void setCustomConditions(Map<String, CustomCondition> map)  {    customConditions = map;  } }PARSER_END(LQMLParser)SKIP : { " " }SKIP : { "\r" | "\t" | "\n" | "#" }// Structural Keyword TokensTOKEN : { < DEF : "def" > }TOKEN : { < LABEL : "label" > }TOKEN : { < DESC : "description" > }TOKEN : { < MATCH : "match" > }TOKEN : { < ACTION : "action" > }TOKEN : { < METRICURI : "metric" > }TOKEN : { < FINALLY : "finally" > }TOKEN : { < AGENT: "agent">}TOKEN : { < ESTIMATE:"estimate">}// Header Keyword TokensTOKEN : { < AUTHOR : "author" > }TOKEN : { < PACKAGE : "package" > }// Condition Keyword TokensTOKEN : { < TYPEOF : "typeof" > }TOKEN : { < ISURI : "isURI"> }TOKEN : { < ISBLANK : "isBlank"> }TOKEN : { < ISLITERAL : "isLiteral"> }/////////////// Helping keywords for condition and action and functions(finally)TOKEN : { < CUSTOM : "custom" > }TOKEN : { < VARIABLE: "var">}TOKEN : { < FUNCTION: "fun">}////////////////// Action Keyword TokensTOKEN : { < COUNT : "count"> }TOKEN : { < COUNTUNIQUE : "countUnique">}/////////////// Function Keyword TokensTOKEN : { < NORMALISE : "normalise"> }TOKEN : { < ADD : "add"> }TOKEN : { < RATIO : "ratio">}TOKEN : { < TOTALTRIPLES : "totalTriples">}/////////////// RuleTOKEN : { < RULE: "rule" > }////////////// Operational TokensTOKEN : { < #CHAR : (["a"-"z" , "A"-"Z"])+ > }TOKEN : { < #NUMBER : (["0"-"9"])+ > }TOKEN : { < STRICT_STR : (< CHAR >)+ < STR > > }TOKEN : { < BOOLEAN : ("TRUE" | "FALSE")>}TOKEN : { < #STR : (< NUMBER > | < CHAR >)*  >  }TOKEN : { < QUOTED_STR: "\"" (~["\""])+ "\"" >}TOKEN : { < LBRACE : "{" >}TOKEN : { < RBRACE : "}" >}TOKEN : { < LPAREN : "(" >}TOKEN : { < RPAREN : ")" >}TOKEN : { < COMMA : ",">}TOKEN : { < COLON : ":" >}TOKEN : { < SEMI_COLON : ";" >}TOKEN : { < PERIOD : "." >}TOKEN : { < QUOTES : "\"" >}TOKEN : { < BOOLEAN_OPERATOR : < EQ > | < NEQ> | < LT > | < GT > | < LTE > | < GTE >  > }TOKEN : { < #EQ : "==" >}TOKEN : { < #NEQ : "!=" >}TOKEN : { < #LT : "<" >}TOKEN : { < #GT : ">" >}TOKEN : { < #LTE : "<=" >}TOKEN : { < #GTE : ">=" >}TOKEN : { < LOGICAL_BINARY_OP: "&" | "|">}TOKEN : { < LOGICAL_NOT : "!">}TOKEN : { < HEADER_INDICATOR : "%%" >}TOKEN : { < ASSIGNMENT_OPERATOR: "=">}TOKEN : { < ASSOCIATION_OPERATOR: "=>">}// LD Specific TokensTOKEN : { < SUBJECT_VAR : "?s" > }TOKEN : { < PREDICATE_VAR : "?p" > }TOKEN : { < OBJECT_VAR : "?o" > }TOKEN : { < IRIref: "<" (~[ ">","<", "\"", "{", "}", "^", "\\", "|", "`", "\u0000"-"\u0020"])* ">" > }// BNF DefinitionMap<String,String>  parse():{ compilerMap = new HashMap<String,String>();}{  extractHeader()  def = extractDefinitionName()  AgentEstimatePerm()  (  	(  		metricUri = extractMetricURI()		AgentEstimatePerm()  		LabelDescRulesPerm()  	) |   	(  		label = extractLabel()  		AgentEstimatePerm()  		MetricUriDescRulesPerm()  	) |  	(  		desc = extractDescription()  		AgentEstimatePerm()  		MetricUriLabelRulesPerm()  	) |  	(  		rules = extractRules()  		AgentEstimatePerm()  		MetricUriLabelDescPerm()  	)  )  AgentEstimatePerm()  finalVal = extractFinally()  < PERIOD >  <EOF>  {  	compilerMap.put("[%%classname%%]",def);  	compilerMap.put("[%%metricuri%%]",metricUri);  	compilerMap.put("[%%label%%]",label);  	compilerMap.put("[%%description%%]",desc);  	Metric metric = new Metric(rules, finalVal);  	compilerMap.put("[%%computefunction%%]",metric.getComputeFunction());  	compilerMap.put("[%%imports%%]",metric.getImports());  	compilerMap.put("[%%variables%%]",metric.getVariables());  	compilerMap.put("[%%metricvaluefuntion%%]",metric.getFinalMetricValueFunction());  	return compilerMap;    }}void extractHeader():{}{  {    compilerMap.put("[%%author%%]",extractAuthor());    compilerMap.put("[%%packagename%%]",extractPackage());  }}String extractAuthor():{  Token t;  String author = "";}{< HEADER_INDICATOR >< AUTHOR >< COLON >t = <QUOTED_STR>{ author = t.image.replace("\"","") ; }{ return author; }}String extractPackage():{  Token t;  String pkg = "";}{  	< HEADER_INDICATOR >	< PACKAGE >	< COLON >	t = <QUOTED_STR>	{ pkg = t.image.replace("\"","")  ; }	{ return pkg; }}String extractDefinitionName():{  Token t;}{	<DEF>	<LBRACE>	t = <STRICT_STR>	{String s = t.image.replace("\"","") ;}	< RBRACE >	< COLON >	{return s;}}String extractLabel():{  Token t;}{	<LABEL>	<LBRACE>	t = <QUOTED_STR>	{ String s = t.image.replace("\"","") ; }	<RBRACE>	<SEMI_COLON>	{return s;}}String extractDescription():{  Token t;}{	<DESC>	<LBRACE>	t = <QUOTED_STR>	{ String s = t.image; }	<RBRACE>	<SEMI_COLON>	{return s;}}RuleSet extractRules():{  RuleSet ruleSet = new RuleSet();  List<Rule> rules = new ArrayList<Rule>();    }{  <RULE>  <LBRACE>  extractRule(rules)  (    extractRule(rules)  )*  <RBRACE>  <SEMI_COLON>  {    ruleSet.setRuleSet(rules);    return ruleSet;  }}void extractRule(List<Rule> rules):{  Rule r = new Rule();  Token t;}{  <VARIABLE>  <PERIOD>  t = <STRICT_STR>  <ASSIGNMENT_OPERATOR>  { r.setResultVar(t.image); }  <MATCH>  <LBRACE>  extractCondition(r)  <RBRACE>  <ASSOCIATION_OPERATOR>  action = extractAction()  <SEMI_COLON>  {    r.setAction(action);    rules.add(r);  }}void extractAutomicCondition(Rule r):{  Condition c;}{  (    <TYPEOF>  	{  	  c = extractTypeOf();  	  r.addCondition(c);  	}  ) |  (    < ISURI >    {      c = extractIsUri();      r.addCondition(c);    }  ) |  (    < ISBLANK >  	{  	  c = extractIsBlank();  	  r.addCondition(c);  	}  ) |  (    < ISLITERAL >    {      c = extractIsLiteral();      r.addCondition(c);    }  ) |  (    < CUSTOM >  	< PERIOD >  	{  	  c = extractCustom();  	  r.addCondition(c);  	}  ) |  {	c = extractNonDefinedCondition();	r.addCondition(c);  }}void extractCompoundCondition(Rule r):{  Token t;}{  <LPAREN>  { r.addOperator("("); }  (    (      t = <LOGICAL_NOT>      { r.addOperator(t.image); }      extractAutomicCondition(r)    ) |    (      extractAutomicCondition(r)    )  )    (    t = <LOGICAL_BINARY_OP>    { r.addOperator(t.image); }    (      (        t = <LOGICAL_NOT>        { r.addOperator(t.image); }        extractAutomicCondition(r)      ) |      (        extractAutomicCondition(r)      )    )  )*  <RPAREN>  { r.addOperator(")"); }}void extractCondition(Rule r):{  Token t;}{  (    (      t = < LOGICAL_NOT >      {        r.addOperator(t.image);      }      (        (          extractAutomicCondition(r)        ) |        (          extractCompoundCondition(r)        )      )    ) |    (      (        extractAutomicCondition(r)      ) |      (        extractCompoundCondition(r)      )    )  )  (    (      t = <LOGICAL_BINARY_OP>      { r.addOperator(t.image); }    )    extractCondition(r)      )*}void extractParams(ArrayList<String> params):{  Token t;}{  <LPAREN>  (     	( t=<SUBJECT_VAR> { params.add(t.image); } ) |    	( t = <PREDICATE_VAR> { params.add(t.image); } )|    	( t = <OBJECT_VAR> { params.add(t.image); } )  )  (    < COMMA >    (     	( t= <SUBJECT_VAR> { params.add(t.image); } ) |    	( t = <PREDICATE_VAR> { params.add(t.image); } )|    	( t = <OBJECT_VAR> { params.add(t.image); } )  	)  )*  <RPAREN>  }Condition extractCustom():{  Token t;  ArrayList<String> params = new ArrayList<String>();}{  t = < STRICT_STR>  {    //c.setClassName(t.image);  	Condition c = customConditions.get(t.image);  }  extractParams(params)  {    c.setParams(params);    c.setConditionType(ConditionType.CUSTOM);    return c;  }}Condition extractIsLiteral():{  Token t;  Condition c = new Condition();  ArrayList<String> params = new ArrayList<String>();}{  	extractParams(params)  	{		c.setConditionType(ConditionType.ISLITERAL);		c.setParams(params);		return c;	  	}  }Condition extractIsBlank():{  Token t;  Condition c = new Condition();  ArrayList<String> params = new ArrayList<String>();}{	extractParams(params)  	{		c.setConditionType(ConditionType.ISBLANK);		c.setParams(params);		return c;	  	}  }Condition extractIsUri():{  Token t;  Condition c = new Condition();  ArrayList<String> params = new ArrayList<String>();}{  	extractParams(params)  	{		c.setConditionType(ConditionType.ISURI);		c.setParams(params);		return c;	  	}}Condition extractTypeOf():{  Token t;  Condition c = new Condition();}{  	<LPAREN>  	(  	  ( t=<SUBJECT_VAR> { c.addParam(t.image); } ) |  	  ( t=<OBJECT_VAR> { c.addParam(t.image); } ) |  	  ( t=<PREDICATE_VAR> {c.addParam(t.image); } )  	)  	<RPAREN>  	t = < BOOLEAN_OPERATOR >  	{  	  c.addParam(t.image);  	}   	t = < IRIref >	{			c.setConditionType(ConditionType.TYPEOF);		c.addParam(t.image);		return c;	}}Condition extractNonDefinedCondition():{  Token t, t2, t3;  DefinedCondition c = new DefinedCondition();  c.setConditionType(ConditionType.NORMAL);}{   	( 	  t = < SUBJECT_VAR > 	  { c.setLhs("?s"); } 	  ( 	   	t2 = < BOOLEAN_OPERATOR > 		t3 = <IRIref> 	  ) | 	  t = < PREDICATE_VAR >	{ c.setLhs("?p"); } 	  ( 	    t2 = < BOOLEAN_OPERATOR > 		t3 = <IRIref> 		{ 		  c.setIsIRI(true); 		} 	  ) | 	  t = < OBJECT_VAR > 	   	  { c.setLhs("?o"); } 	  ( 	   	t2 = < BOOLEAN_OPERATOR > 		( 			t3 = <IRIref> 			{ 		  	 c.setIsIRI(true); 			}| 			t3 = <QUOTED_STR> 		) 	  ) 	) 	{ 	  	c.setBooleanOperator(t2.image); 		c.setRhs(t3.image); 	  	return c; 	}}void extractFunctionParams(List< FunctionParam> result):{}{  < LPAREN>  extractFunctionParam(result)  (    < COMMA>    extractFunctionParam(result)  )*  < RPAREN>}void extractFunctionParam(List<FunctionParam> funParams):{  Token t;  FunctionParam param = new FunctionParam();  List<FunctionParam> subParams = new ArrayList< FunctionParam>();  Function fun = new Function();}{	(	  < ADD>	  (	    extractFunctionParams(subParams)	  	{	  	  param.setParamType(FunctionParamType.FUNCTION);	  	  fun.setFunctionType(FunctionType.ADD);	  	  fun.setParams(subParams);	  	  param.setFunction(fun);	  	}  	  ) |	  < RATIO>	  (	    extractFunctionParams(subParams)	    {	      param.setParamType(FunctionParamType.FUNCTION);	      	  	  fun.setFunctionType(FunctionType.RATIO);	  	  fun.setParams(subParams);	  	  param.setFunction(fun);	    }	  ) |	  < NORMALISE>	  (	    extractFunctionParams(subParams)	    {	      param.setParamType(FunctionParamType.FUNCTION);	      	  	  fun.setFunctionType(FunctionType.NORMALISE);	  	  fun.setParams(subParams);	  	  param.setFunction(fun);	    }	  ) |	  < VARIABLE>	  (	    < PERIOD>	    t = <STRICT_STR>	    {	      param.setParamType(FunctionParamType.VAR);	      param.setVarName(t.image);  	    }	  ) |	  < TOTALTRIPLES >(	    {	      param.setParamType(FunctionParamType.TOTALTRIPLES);	      param.setVarName("totalTriplesAssessed");	    }	  )	)	{	  funParams.add(param);	}  }Function extractFinally():{  Token t;  Function fun = new Function();  List<FunctionParam > funParams = new ArrayList<FunctionParam>();}{  < FINALLY>  < LBRACE>  (    (      < ADD>      {        fun.setFunctionType(FunctionType.ADD);      }    ) |    (      < RATIO>      {        fun.setFunctionType(FunctionType.RATIO);      }    ) |    (      < NORMALISE>      {        fun.setFunctionType(FunctionType.NORMALISE);      }    )  )  extractFunctionParams(funParams)  {    fun.setParams(funParams);  }   < RBRACE>  {    return fun;  }}Action extractAction():{  Token t;  Action action = new Action();  ArrayList<String> params = new ArrayList<String>();}{  < ACTION >  < LBRACE >  (    (      < COUNT >      extractParams(params)      {      	action.setActionType(ActionType.COUNT);      	action.setParams(params);      }    ) |    (      < COUNTUNIQUE >      extractParams(params)      {      	action.setActionType(ActionType.COUNTUNIQUE);      	action.setParams(params);      }    ) |    (      < CUSTOM >      < PERIOD >      t = < STRICT_STR>  	  {    	action.setClassName(t.image);  	  }  	  extractParams(params)      {        action.setActionType(ActionType.CUSTOM);      }    )  )  < RBRACE >  	  { return action;}}String extractEstimate():{	Token t;   }{	<ESTIMATE>	<LBRACE>	t = < BOOLEAN>	{	  	String s = t.image;	}	<RBRACE>	<SEMI_COLON>	{		return s;  	}}String extractAgentURI():{	Token t;}{  	< AGENT >  	< LBRACE >  	t = < IRIref >  	{  		String s = t.image.replace("<","").replace(">","");  	}  	< RBRACE >  	< SEMI_COLON >  	{  	  	return s;  	}}String extractMetricURI():{	Token t;}{  <  METRICURI >  < LBRACE >  t = < IRIref >  {String s = t.image.replace("<","").replace(">","") ;}  < RBRACE >  <SEMI_COLON>  {return s;}  }void LabelDescRulesPerm():{}{	(		label = extractLabel()		AgentEstimatePerm()		DescRulesPerm()	) |	(		desc = extractDescription()		AgentEstimatePerm()		LabelRulesPerm()	) |	(		rules = extractRules()		AgentEstimatePerm()		LabelDescPerm()	)}void MetricUriDescRulesPerm():{}{	(		metricUri = extractMetricURI()		AgentEstimatePerm()		DescRulesPerm()	) |	(		desc = extractDescription()		AgentEstimatePerm()		MetricUriRulesPerm()	) |	(		rules = extractRules()		AgentEstimatePerm()		MetricUriDescPerm()	)}void MetricUriLabelRulesPerm():{}{	(		metricUri = extractMetricURI()		AgentEstimatePerm()		LabelRulesPerm()	) |	(		label = extractLabel()		AgentEstimatePerm()		MetricUriRulesPerm()	) |	(		rules = extractRules()		AgentEstimatePerm()		MetricUriLabelPerm()	)}void MetricUriLabelDescPerm():{}{	(		metricUri = extractMetricURI()		AgentEstimatePerm()		LabelDescPerm()	) |	(		label = extractLabel()		AgentEstimatePerm()		MetricUriDescPerm()	) |	(		desc = extractDescription()		AgentEstimatePerm()		MetricUriLabelPerm()	)}void MetricUriDescPerm():{}{	(		metricUri = extractMetricURI()		AgentEstimatePerm()	) |	(		desc = extractDescription()		AgentEstimatePerm()	)}void MetricUriRulesPerm():{}{	(		metricUri = extractMetricURI()		AgentEstimatePerm()	) |	(		rules = extractRules()		AgentEstimatePerm()	)}void MetricUriLabelPerm():{}{	(		metricUri = extractMetricURI()		AgentEstimatePerm()	) |	(		label = extractLabel()		AgentEstimatePerm()	)}void DescRulesPerm():{}{	(		desc = extractDescription()		AgentEstimatePerm()		rules = extractRules()	) |	(		rules = extractRules()		AgentEstimatePerm()		desc = extractDescription()	)}void LabelRulesPerm():{}{	(		label = extractLabel()		AgentEstimatePerm()	) |	(		rules = extractRules()		AgentEstimatePerm()	)}void LabelDescPerm():{}{	(		label = extractLabel()		AgentEstimatePerm()	) |	(		desc = extractDescription()		AgentEstimatePerm()	)}void AgentEstimatePerm():{  }{  	LOOKAHEAD(3)	(		(			agentUri = extractAgentURI()  		)?		(			estimate = extractEstimate()  		)?  	) |	(		(			estimate = extractEstimate()  		)?		(			agentUri = extractAgentURI()  		)?  	)  }